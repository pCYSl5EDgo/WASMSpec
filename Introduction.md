# はじめに

WebAssembly(WASM[^1])は、効率的な実行とコンパクトな表現のために設計された、安全でポータブルな低レベルコードフォーマットです。
その主な目的は、Web上での高性能なアプリケーションを可能にすることですが、Web特有の仮定やWeb特有の機能を提供しないため、他の環境でも採用することができます。

WebAssemblyは、W3Cによって開発されたオープンでスタンダードな規格です。

このドキュメントでは、WebAssemblyのコアとなる標準規格のバージョン1.1について説明します。
将来的には機能が追加された新しいリリースによって置換されるでしょう。

## デザインゴール/設計目標について

WebAssemblyの設計目標は以下の通りです。

 - 高速、安全、ポータブルな文法。
    - 高速: 現代のすべてのハードウェアに共通する機能を利用して、ほぼネイティブに近いコード性能で実行します。
    - 安全: コードはメモリセーフ[^2]なサンドボックス環境下で検証され、データ破損やセキュリティ侵害を防ぎながら実行されます。
    - 十分に定義されている：有効なプログラムとその動作を完全かつ正確に定義し、推論しやすいようにしています。
    - ハードウェアに依存しない: デスクトップ、モバイルデバイス、組み込みシステムを問わず、最新のすべてのアーキテクチャでコンパイルすることができます。
    - 言語に依存しない: 特定の言語、プログラミングモデル、オブジェクトモデルを優遇しません。
    - プラットフォームに依存しない：ブラウザに組み込んだり、スタンドアロンのVMとして実行したり、他の環境に統合したりすることができます。
    - オープン: プログラムは、シンプルで統一的な方法で環境との相互運用が可能です。
 - 効率的でポータブルな表現。
    - コンパクト：一般的なテキスト形式やネイティブコード形式よりも小さいバイナリ形式で、転送速度が速い。
    - モジュール性：プログラムを小さな部分に分割して、送信、キャッシュ、使用を別々に行うことができます。
    - 効率的：デコード、検証、コンパイルを高速なシングルパスで行えます。JITまたはAOTコンパイルでも同じようにシングルパスで行えます。
    - ストリーミング可能：デコード、検証、コンパイルを、すべてのデータを見る前に、できるだけ早く開始することができます。
    - 並列化可能：デコード、検証、コンパイルを多くの独立した並列タスクに分割できます。
    - ポータブル: 現代のハードウェアでは広くサポートされていないアーキテクチャ上の仮定をしません。

WebAssemblyのコードは、特にWebブラウザのような環境で、検査やデバッグが容易であることも意図されていますが、そのような機能はこの仕様の範囲を超えています。

## この仕様の適応範囲について

WebAssemblyは仮想命令セットアーキテクチャ（仮想ISA）です。
そのため、多くのユースケースがあり、多くの異なる環境に組み込むことができます。
それらの多様性を包含し、最大限の再利用を可能にするために、WebAssemblyの仕様はいくつかのドキュメントに分割され、レイヤー化されています。

このドキュメントは、WebAssembly のコア仮想命令セット層に関係しています。
これは、命令セット、バイナリエンコーディング、検証、実行セマンティクス、およびテキスト表現を定義しています。
しかし、WebAssemblyプログラムが実行される特定の環境とどのように相互作用するか、また、そのような環境からどのように呼び出されるかについては定義していません。

代わりに、この仕様はWebのような特定の環境へのインターフェースを定義する追加のドキュメントによって補完されます。
これらはそれぞれ与えられた環境に適した`WebAssembly`APIを定義します。

## セキュリティについて

WebAssemblyは、コードが実行される環境への直接的アクセスを許可しません。
I/O、リソースへのアクセス、またはオペレーティングシステムの呼び出しなどの環境との相互作用は、エンベッダーによって提供された機能を呼び出してWebAssemblyモジュールにインポートすることによってのみ実行することができます。
エンベッダーは、インポートのために利用可能にする機能を制御または制限することによって、それぞれの環境に適したセキュリティ・ポリシーを確立することができます。
このような考慮事項は、エンベッダーの責任であり、特定の環境のためのAPI定義の対象となります。

WebAssemblyは、ホストのハードウェア上で直接実行されるマシンコードに翻訳されるように設計されているため、ハードウェアレベルでのサイドチャネル攻撃に対して潜在的に脆弱です。
これが懸念される環境では、エンベッダーは`WebAssembly`の計算を分離するために適切な緩和策を配置しなければならないかもしれません。

## 依存関係について

WebAssemblyは、2つの既存の標準規格に依存しています。

[IEEE 754-2019](https://ieeexplore.ieee.org/document/8766229)：浮動小数点データの表現とそれぞれの数値演算のセマンティクス。
[Unicode](http://www.unicode.org/versions/latest/):インポート/エクスポート名とテキスト形式の表現のためのものです。

ただし、この仕様を自己完結的なものとするため、浮動小数点値の二進表現と丸め、Unicode文字の値範囲とUTF-8エンコーディングなど、前述の標準規格の関連する部分をこの仕様の一部として重複定義し、形式化しています。

# 概論

## 構成諸要素

WebAssemblyは、低レベルでアセンブリのようなプログラミング言語にコンパイルされます。
この言語は以下の概念を中心に構成されています。

 - 値
    - `WebAssembly`は、4 つの基本的な値の型のみを提供します。
    - これらは整数と[IEEE 754-2019](https://ieeexplore.ieee.org/document/8766229)の数値でそれぞれ32ビット幅と64ビット幅があります。
    - 32 ビット整数は、真偽値として、またメモリアドレスとしても機能します。
    - これらの型に対する通常の操作はそれらの間の変換の完全な行列を含めて利用可能です。
    - 符号付き整数型と符号なし整数型の区別はありません。
    - その代わり、整数はそれぞれの演算によって符号なしまたは符号付きの2の補数表現のいずれかとして解釈されます。
 - 命令
    - WebAssemblyの計算モデルは、スタックマシンに基づいています。
    - コードは、順番に実行される命令のシーケンスで構成されています。
    - 命令は暗黙のオペランド・スタック[^3]上の値を操作しますが、2つの主要なカテゴリに分類されます。
    - 単純な命令はデータに対する基本的な操作を行います。
    - これらの命令はオペランド・スタックから引数を取り出し、結果をオペランド・スタックに押し戻します。
    - 制御命令は、制御フローを変更します。
    - 制御フローは構造化されており、ブロック、ループ、条件式などのよく入れ子になった構造で表現されています。
    - ジャンプ命令は、そのような構造のみをターゲットにすることができます。
 - トラップ例外
    - いくつかの条件の下では、特定の命令がトラップを発生させ、即座に実行を中止させることがあります。
    - トラップ例外は`WebAssembly`コードでは処理できませんが、外部環境に報告されます。
 - 関数
    - コードは個別の関数で構成されています。
    - 各関数は一連の値をパラメータとして受け取り、一連の値を結果として返します。[^4]
    - 関数は再帰的な呼び出しも含めて相互に呼び出すことができ、その結果直接アクセスできない暗黙の呼び出しスタックが生成されます。
    - また、関数は仮想レジスタとして使用可能なmutableなローカル変数を宣言することもできます。
 - テーブル
    - テーブルは特定の要素型の不透明な値の配列です。
    - これによりプログラムはインデクサを通して間接的に動的な値を選択することができます。
    - 現在、利用可能な要素型は、型なしの関数参照のみです。
    - これによりプログラムはテーブルへのインデクサを通して間接的に関数を呼び出すことができます。
    - 例えば、これによりテーブルインデックスを介して関数ポインタをエミュレートすることができます。
 - リニアメモリ(線形メモリ)
    - リニアメモリとは、連続したmutableなbyte配列のことです。
    - このようなメモリは初期サイズで作成されますが、動的に成長させることができます。
    - プログラムは、任意のバイトアドレス（アラインメントされていないものを含む）を指定してリニアメモリから値をロードしたりストアしたりすることができます。
    - 整数のロードおよびストアは、それぞれの値タイプのサイズよりも小さいストレージサイズを指定することができます。
    - アクセスが現在のメモリサイズの範囲内にない場合、トラップ例外が発生します。
 - モジュール
    - `WebAssembly`のバイナリは、関数、テーブル、リニアメモリの定義を含むモジュールの形をしています。
    - 定義は、モジュールと名前のペアと適切な型を指定してインポートすることもできます。
    - 各定義は、オプションで1つ以上の名前でエクスポートすることができます。
    - 定義に加えて、モジュールはメモリやテーブルの初期化データを定義することができ、それは与えられたオフセットにコピーされたセグメントの形をしています。
    - また、自動的に実行される開始関数を定義することもできます。
 - エンベッダー
    - `WebAssembly`の実装は通常、ホスト環境に組み込まれます。
    - この環境は、モジュールのロードがどのように開始されるか、インポートがどのように提供されるか（ホスト側の定義を含む）、エクスポートがどのようにアクセスできるかを定義します。
    - しかし、特定の組み込みの詳細はこの仕様の範囲を超えており、代わりに補完的な環境固有のAPI定義によって提供されます。

## フェーズ

`WebAssembly`は概念的には3つのフェーズに分かれています。

 - デコード
    - WebAssemblyモジュールはバイナリ形式で配布されます。
    - デコードはそのフォーマットを処理し、モジュールの内部表現に変換します。
    - この仕様では、この表現は抽象構文によってモデル化されていますが、実際の実装では、代わりにマシンコードに直接コンパイルすることができます。
 - バリデーション
    - デコードされたモジュールは有効でなければなりません。
    - バリデーションはモジュールが意味のある安全なものであることを保証するために、多くの条件をチェックします。
    - 特に関数とそのボディ内の命令シーケンスの型チェックを行い、例えばオペランドスタックが一貫して使用されていることを確認します。
 - 実行
    - 最後に、有効なモジュールを実行することができます。実行はさらに2つのフェーズに分けることができます。
    - インスタンス化
        - モジュールのインスタンスはモジュールの動的な表現であり、それ自身の状態と実行スタックを備えています。
        - インスタンス化は、すべてのインポートの定義を与えられたモジュール本体自体を実行します。
        - グローバルメモリ、グローバルテーブルを初期化し、モジュールの開始関数を定義されている場合呼び出します。
        - モジュールのエクスポートされた要素のインスタンスを戻り値とします。
    - 呼び出し
        - 一度インスタンス化されると、モジュールのインスタンス上でエクスポートされた関数を呼び出すことで、さらなる WebAssembly の計算を開始することができます。
        - 必要な引数が与えられると、それぞれの関数が実行されその結果が返されます。

[^1]: `WebAssembly`の短縮形であり、頭字語ではありません。
[^2]: いかなるプログラムであっても`WebAssembly`のメモリモデルを壊すことはできません。もちろん、WebAssemblyにコンパイルされた安全でない言語が、WebAssemblyのリニアメモリ内など、それ自身のメモリレイアウトを壊さないことを保証することはできません。
[^3]: 実際には、実装は実際のオペランド・スタックを維持する必要はありません。その代わりに、スタックは命令によって暗黙的に参照される匿名レジスタの集合として見ることができます。型システムは、スタックの高さ、つまり参照されるレジスタが常に静的に知られていることを保証します。
[^4]: 現在のバージョンのWebAssemblyでは、結果の値は最大でも1つかもしれません。